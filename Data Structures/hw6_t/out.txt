#include<iostream>#include<fstream>#include<string>#include<vector>#include<algorithm>#include"input.h"usingnamespacestd;template<classT>voidprint(vector<T>&input){for(inti=0;i<input.size();i++){cout<<input[i]<<endl;}}boolhelp(strings,stringss){returns.size()<ss.size();}boolcheck_size(string&test,vector<constraint>constraints){for(inti=0;i<constraints.size();i++){if(test.size()==constraints[i].len()){returntrue;}}returnfalse;}voidsub_a(string&base,intheight,intwidth,vector<string>&dict,vector<constraint>&constraints,int&row,int&col,vector<string>&board,vector<found_word>&found_words){if(row>=height){return;}if(base.size()>=dict[0].size()){for(inti=0;i<dict.size();i++){if(base==dict[i]){if(check_size(base,constraints)){found_wordb(base,"a");for(intj=col;j<base.size()+col;j++){pointp(row,j);b.c_pushback(p);}found_words.push_back(b);col+=base.size();base=board[row].substr(col,board[row].size()-col);sub_a(base,height,width,dict,constraints,row,col,board,found_words);}else{std::cout<<"Numberofsolutions:0"<<std::endl;exit(0);}}}}if(row<height){if(base.size()>2){base=base.substr(0,base.size()-1);sub_a(base,height,width,dict,constraints,row,col,board,found_words);}if(base.size()<=2andcol!=width){col+=1;base=board[row].substr(col,board[row].size()-col);sub_a(base,height,width,dict,constraints,row,col,board,found_words);}if(col>=width){row+=1;if(row>=height){return;}base=board[row];col=0;sub_a(base,height,width,dict,constraints,row,col,board,found_words);}}if(row>=heightandcol>=width){return;}return;}voidsub_d(string&base,int&height,int&width,vector<string>&dict,vector<constraint>&constraints,int&row,int&col,vector<string>&board,vector<found_word>&found_words,string&ref){if(col>=width){return;}for(inti=0;i<dict.size();i++){if(base==dict[i]){if(check_size(base,constraints)){found_wordb(base,"d");for(intj=row;j<base.size()+row;j++){pointp(j,col);b.c_pushback(p);}found_words.push_back(b);row+=base.size();base=ref.substr(row,ref.size()-row);sub_d(base,height,width,dict,constraints,row,col,board,found_words,ref);}else{std::cout<<"Numberofsolutions:0"<<std::endl;exit(0);}}}if(col<width){if(base.size()>2){base=base.substr(0,base.size()-1);sub_d(base,height,width,dict,constraints,row,col,board,found_words,ref);}if(base.size()<=2androw!=height){row+=1;base=ref.substr(row,ref.size()-row);sub_d(base,height,width,dict,constraints,row,col,board,found_words,ref);}if(row>=height){col+=1;if(col>=width){return;}ref="";for(inti=0;i<height;i++){charc=board[i][col];strings(1,c);ref+=s;}base=ref;row=0;sub_d(base,height,width,dict,constraints,row,col,board,found_words,ref);}}if(row>=heightandcol>=width){return;}return;}boolvalid(vector<found_word>&solutions,vector<constraint>&constraints){boolcheck=true;sort(solutions.begin(),solutions.end());for(inti=0;i<constraints.size();i++){if(constraints[i].len()!=solutions[i].getw().size()){check=false;returncheck;}}returncheck;}voidpossible_indexes(intoffset,intk,vector<int>&indexes,vector<int>&k_,vector<vector<int>>&valid_i){if(k==0){valid_i.push_back(indexes);return;}for(inti=offset;i<=k_.size()-k;++i){indexes.push_back(k_[i]);possible_indexes(i+1,k-1,indexes,k_,valid_i);indexes.pop_back();}return;}boolunique(vector<found_word>&solution){boolcheck=true;for(inti=0;i<solution.size()-1;i++){if(solution[i].getw()==solution[i+1].getw()){return!check;}}returncheck;}voidpossible_board(vector<vector<int>>&valid_i,vector<constraint>&constraints,vector<found_word>&found_words,vector<vector<found_word>>&possible){vector<found_word>solution;for(inti=0;i<valid_i.size();i++){for(intj=0;j<valid_i[i].size();j++){solution.push_back(found_words[valid_i[i][j]-1]);}sort(solution.begin(),solution.end());if(valid(solution,constraints)){if(unique(solution)){possible.push_back(solution);}}solution.clear();}}vector<found_word>search(intheight,intwidth,vector<string>&board,vector<constraint>&constraints,vector<string>&dict){stringbase=board[0];base=base.substr(0,width);introw=0;intcol=0;vector<found_word>found_words;sub_a(base,height,width,dict,constraints,row,col,board,found_words);base="";row=0;col=0;for(inti=0;i<height;i++){charc=board[i][0];strings(1,c);base+=s;}stringref=base;sub_d(base,height,width,dict,constraints,row,col,board,found_words,ref);returnfound_words;}voidbuild_board(vector<vector<string>>&boards,vector<vector<found_word>>&possible_board,intwidth,intheight,vector<string>&board,vector<constraint>&constraints,vector<string>&dict){for(inti=0;i<possible_board.size();i++){vector<string>test;for(intu=0;u<height;u++){stringline(width,'#');test.push_back(line);}for(intj=0;j<possible_board[i].size();j++){for(intk=0;k<possible_board[i][j].coordinates.size();k++){test[possible_board[i][j].coordinates[k].first()][possible_board[i][j].coordinates[k].second()]='?';}}for(intb=0;b<test.size();b++){for(intv=0;v<test[b].size();v++){if(test[b][v]=='?'){test[b][v]=board[b][v];}}}vector<found_word>baseline=search(height,width,test,constraints,dict);sort(baseline.begin(),baseline.end());if(baseline==possible_board[i]){boards.push_back(test);test.clear();}test.clear();}}voidfinal_form(vector<vector<string>>&boards){for(inti=0;i<boards.size();i++){cout<<"Board:"<<endl;print(boards[i]);}}intmain(intargc,char*argv[]){std::ifstreamin_str(argv[1]);if(!in_str.good()){std::cerr<<"Can'topen"<<argv[1]<<"toread.\n";exit(1);}vector<string>dict;stringword;while(!in_str.eof()){in_str>>word;dict.push_back(word);}std::sort(dict.begin(),dict.end(),help);std::vector<std::string>::iteratorunique=std::unique(dict.begin(),dict.end());dict.resize(std::distance(dict.begin(),unique));std::ifstreamfboard(argv[2]);if(!fboard.good()){std::cerr<<"Can'topen"<<argv[2]<<"toread.\n";exit(1);}vector<string>board;vector<constraint>constraints;vector<found_word>found_words;intlength;stringnum;while(!fboard.eof()){fboard>>word;if(word[0]=='!'){continue;}elseif(word[0]=='+'){if(word.size()==2){num=word.substr(1,1);length=stoi(num);}else{num=word.substr(1,word.size()-1);length=stoi(num);}constraintc(length);constraints.push_back(c);}else{board.push_back(word);}}intheight=board.size()-1;intwidth=board[0].size();sort(constraints.begin(),constraints.end());found_words=search(height,width,board,constraints,dict);vector<vector<found_word>>possible;vector<int>indexes;vector<int>k_;vector<vector<int>>valid_i;intc_size=constraints.size();intf_size=found_words.size();intoffset=0;for(inti=0;i<f_size;i++){k_.push_back(i+1);}possible_indexes(offset,c_size,indexes,k_,valid_i);possible_board(valid_i,constraints,found_words,possible);vector<vector<string>>boards;build_board(boards,possible,width,height,board,constraints,dict);if(string(argv[3])=="one_solution"){if(string(argv[4])=="count_only"){if(boards.size()>=1){cout<<"Numberofsolution(s):1"<<endl;return0;}else{cout<<"Numberofsolution(s):0"<<endl;return0;}}elseif(string(argv[4])=="print_boards"){if(boards.size()>=1){cout<<"Numberofsolution(s):1"<<endl;cout<<"Board:"<<endl;print(boards[0]);}}}elseif(string(argv[3])=="all_solutions"){if(string(argv[4])=="count_only"){if(boards.size()>=1){cout<<"Numberofsolution(s):"<<boards.size()<<endl;return0;}else{cout<<"Numberofsolution(s):0"<<endl;return0;}}elseif(string(argv[4])=="print_boards"){if(boards.size()>=1){cout<<"Numberofsolution(s):"<<boards.size()<<endl;final_form(boards);}}}return0;}