# -*- coding: utf-8 -*-
"""dl_pa3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16GSllhU1P72SV9PZJaoh_XriE2jP8TE6
"""

# !pip install -Uqq ipdb
# import ipdb

# Commented out IPython magic to ensure Python compatibility.
# %pdb off

import tensorflow as tf
from tensorflow.keras import layers, models
import matplotlib.pyplot as plt
import math
import numpy as np
from sklearn.metrics import classification_report
from google.colab import drive

drive.mount('/content/gdrive')

class cnn_model(tf.keras.Model):
  def __init__(self):
    super(cnn_model, self).__init__()
    self.conv_layer_1 = layers.Conv2D(16, 5, strides=1, padding='valid', activation='relu')
    self.pooling_layer_1 = layers.MaxPool2D(2, 2)
    self.conv_layer_2 = layers.Conv2D(32, 5, strides=1, padding='valid', activation='relu')
    self.pooling_layer_2 = layers.MaxPool2D(2, 2)
    self.conv_layer_3 = layers.Conv2D(64, 3, strides=1, padding='valid', activation='relu')
    
    self.flatten = layers.Flatten()
    
    self.fully_connected = layers.Dense(500, activation='relu')
    self.output_layer = layers.Dense(10, activation=tf.keras.activations.softmax)
  def call(self, training_data):
    conv_1 = self.conv_layer_1(training_data)
    pool_1 = self.pooling_layer_1(conv_1)
    conv_2 = self.conv_layer_2(pool_1)
    pool_2 = self.pooling_layer_2(conv_2)
    conv_3 = self.conv_layer_3(pool_2)
    
    flat = self.flatten(conv_3)
    
    full_conn = self.fully_connected(flat)
    return self.output_layer(full_conn)

training_data = np.load('/content/gdrive/My Drive/Colab_Notebooks/pa3/training_data.npy') /255
training_label = tf.reshape(tf.one_hot(np.load('/content/gdrive/My Drive/Colab_Notebooks/pa3/training_label.npy'),10),(50000,10))

testing_data = np.load('/content/gdrive/My Drive/Colab_Notebooks/pa3/testing_data.npy') /255
testing_label = tf.reshape(tf.one_hot(np.load('/content/gdrive/My Drive/Colab_Notebooks/pa3/testing_label.npy'),10),(5000,10))

batch = 90
epochs = 13
class_names = ['airplane', 'automobile', 'bird', 'cat','deer', 'dog', 'frog', 'horse', 'ship', 'truck']

model = cnn_model()

model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=7.65e-4, beta_1 = .75, beta_2 = .95, epsilon = 1e-7),loss='categorical_crossentropy', metrics=['accuracy'])

completed_model = model.fit(training_data, training_label, validation_data=(testing_data, testing_label),batch_size=batch, epochs=epochs)

n = np.arange(0, epochs)

plt.figure()
plt.plot(n, completed_model.history['loss'], label="train loss")
plt.plot(n, completed_model.history['val_loss'], label="validation loss")
plt.plot(n, completed_model.history['accuracy'], label="train accuracy")
plt.plot(n, completed_model.history['val_accuracy'], label="validation accuracy")
plt.title('Training Loss + Accuracy')
plt.xlabel("Epochs")
plt.ylabel("Loss & Accuracy")
plt.legend()
plt.show()

Y_test = np.argmax(testing_label, axis=1) # Convert one-hot to index
y_pred = np.argmax(model.predict(testing_data), axis=-1)
print(classification_report(Y_test, y_pred))

model.save_weights('/content/gdrive/My Drive/Colab_Notebooks/pa3/model_weights')

model2 = cnn_model()
model2.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=7.65e-4, beta_1 = .75, beta_2 = .95, epsilon = 1e-7),loss='categorical_crossentropy', metrics=['accuracy'])
loss, acc = model2.evaluate(testing_data, testing_label, verbose=2)
print("Untrained model, accuracy: {:5.2f}%".format(100 * acc))

model2.load_weights('/content/gdrive/My Drive/Colab_Notebooks/pa3/model_weights')

# Re-evaluate the model
loss, acc = model2.evaluate(testing_data, testing_label, verbose=2)
print("Restored model, accuracy: {:5.2f}%".format(100 * acc))

filters, biases = model2.layers[0].get_weights()
f_min, f_max = filters.min(), filters.max()
filters = (filters-f_min)/(f_max-f_min)

figure,axis = plt.subplots(nrows=2,ncols=8)

index =0
for i in range(2):
  for j in range(8):
    f_num = (i*2)+j
    f = filters[:, :, :, f_num]
    
    axis[i,j].set_xticks([])
    axis[i,j].set_yticks([])
    axis[i,j].set_title("Filter: #"+str(index),fontsize=8)
    axis[i,j].imshow(f)
    index+=1